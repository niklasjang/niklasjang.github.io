---
title: "[기술면접] 데이터베이스"
excerpt: ""
date: 2020-10-25
categories:
  - JobInterview
tags:
  - JobInterview
toc : true
toc_label: "Table of contents"
toc_icon: "list"  # corresponding Font Awesome icon name (without fa prefix)
toc_sticky: true
classes: wide
---

# 데이터베이스

사용 이유 : 파일 시스템에서의 한계를 극복하기 위해
보완 :
  - 데이터 종속성 : 프로그램의 구조가 데이터의 구조에 영향을 받음. 데이터가 바뀌면 프로그램이 바뀌어야 함.
  - 데이터 중복성
  - 데이터 불일치 : 다중 수정되는 경우 불일치 가능성

# 인덱스
테이블의 모든 데이터를 검색하면 느리다. 컬럼의 값과 해당 레코드가 저장된 주소를 키/값 쌍으로 인덱스를 만들어 준다.
  
인덱스의 경우 select는 속도가 빨라지지만, insert의 경우 추가적인 삭입, delete시 index를 사용하지 않는다는 표시를 남기는 등 추가적인 작업이 필요하다. 따라서 이름/나이/성별에서 이름과 같이 다양한 경우의 수가 존재하는 컬럼에 대해서 적용해야 효율이 좋다.  

인덱스를 구성하는 자료구조는 B+Tree, Hash 등이 있다.  

## 인덱스 자료구조

- B+ Tree :
- Hash : 컬럼의 값으로 해시 값을 계산해서 인덱싱

## 정규화

좋은 릴레이션으로 만드는 과정을 정규화라고 하고 일련의 규칙이 있다. 이 때 규칙은 함수적 종속성을 기준으로 나눈다. X의 값이 Y의 값을 유일하게 결정한다면 X는 Y를 함수적으로 결정한다고 한다.  

제1 정규형 : 릴레이션에 속한 모든 도메인이 원자값
제2 정규형 : non-PK가 PK에 대해 부분 함수적 종속하지 않음(PK가 non-PK를 유일하게 결정. PK가 모두 주어저야 non-PK 식별 가능)
제3 정규형 : non-PK가 PK에 의해 이행적 종속하지 않음
  - 학번 -> 학과명, 학과명 -> 학과전화번호 알 수 있는 경우 table(학번/학과명/학과전화번호)는 제3정규형 위배.
  - table(학번/학과명), tagle(학과명,학과전화번호)로 구분해야 함.
BCNF : 결정자가 그 자체 모두가 후보키. (결정자이고 후보키가 아닌 것 제거)
  - table(A, a, B, b1,b2)
  - A -> a 이고 B -> {b1,b2} 인 경우 후보키는 {A,B}이다.
  - A와 B를 알아야 a,b1,b2를 모두 알수 있게 하는 종속성을 수정하는 것은 틀린 방법
  - table(A,a) table(B,b1,b2) table(A,B)로 나누어야 한다.
제 4,5는 사용하지 않음.

단점 : join 연산이 많아진다. 응답 속도가 느려질 수 있다.

## 트랜잭션

정의 : DB의 상태를 변화시키는 하나의 논리적 작업 단위
특징 : 
  - Atomic  원자성 : commit or rollback
  - Consist 일관성 : 트랜잭션 성공 전후 DB 상태가 유지된다(데이터 타입 등)
  - Isolate 독립성 : 둘 이상의 트랜잭션에 대해, 실행 도중에 다른 트랜잭션에 의해 참조될 수 없다. 
  - Durable 영속성 : 성공적으로 완료된 트랜잭션은 시스템이 고장나도 영구적으로 반영된다.

## 트랜잭션 교착상태

Insert, Update, Delete를 수행하면 기본적으로 행에 대한 lock을 얻는다. 
트랜잭션 1과 2가 각각 테이블 A,B를 생성했다고 하자. 이때 1과 2는 A와 B의 첫번째 행에 대해서 lock을 얻는다.
이때 1,2를 커밋하지 않고 1이 B에 2가 A에 접근한다면 데드락에 걸린다.  

이를 피하기 위해서는 트랜잭션을 자주하고 정해진 순서대로 테이블에 접근하는 것이 필요하다. 

## Statement, PreparedStatement

전자는 dynamic sql이고 후자는 static sql이다. 
전자는 실행 중에 파싱 타입을 하지만 퍼포먼스가 향상될 수 있다. 다양한 쿼리를 동적으로 날릴 수 있기 때문이다.
후자는 미리 변수를 바인딩해서 쿼리가 미리 컴파일될 수 있고, 반복적으로 수행할 경우 미리 컴파일된 쿼리를 사용하여 빠르다.
하지만 동적 쿼리를 통해 성능이 향상되는 것을 놓지게 된다.  

# SQL, NOSQL

NOSQL : Not Only SQL
  - 키:값, 문서 형식의 데이터 모델 이용
  - 대용량 데이터를 효율적으로 처리할 필요가 있을 때, 데이터 분산처리, 빠른 IO등이 필요할 때 사용

## NOSQL 종류

key/value 형 : Redis
  - 메모리 기반의 키/값 구조 데이터 관리 시스템
  - 모든 데이터를 메모리에 저장하고 조회.
  - 빠른 IO에 최적화, 복잡한 조회 연산 비지원
  - 비 관계형 데이터베이스
문서 형 : MongoDB
  - 스키마가 없다. 
  - 필드 추가 제거가 자유롭다.
  - 조인과 트랜잭션을 지원하지 않는다?
  - 문서에 대한 키를 ID로 표현하고 O(1)에 접근할 수 있다. 
  - B 트리 인덱스를 사용하여 2차 인덱스를 생성한다. B 트리는 크기가 커질수록 새로운 데이터 입력과 삭제에 성능이 떨어진다.
  - 따라서 읽기와 쓰기 비율이 7:3 정도에서 가장 좋은 성능을 보인다. 
  - 중앙 집중식 로그 저장, 통계 정보 저장 등에 사용된다. 
  
## Redis :Remote Dictionary Server

장점 : 
  - value값으로 string, list, set, sorted set, hash 등을 지원(리스트, 배열과 같은 데이터를 처리하는데 유용)
  - 여러 프로세스에서 같은 key에 갱신 요청시 Atomic 처리 함수를 제공
  - 메모리를 활용하면서 영속적인 데이터 보존(메모리와 디스크에 모두 저장. 스냅샷을 통해 해당 시점으로 복구 가능) 
  - Redis Server는 싱글쓰레드로 수행됨. 따라서 서버 하나에서 여러 개의 Redis 서버를 띄울 수 있음.(Master-slave)
단점 :
  - 쿠팡 2019년 7월 상품 재고가 0으로 표시되어 구매 불가능한 에러 발생
  - 처리 데이터가 많아질수록 더 많은 메모리를 요구해서 결국 용량 부족으로 오류 및 장애 가능성.
극복 :
  - expire 기능 : 모든 key에 expire 값을 추가해서  timeout을 설정한다. 재접근이 되면 timeout이 갱신된다. 
이해 : 
  - 실시간 랭킹 서버의 경우 ID와 score를 저장하고, 저장된 값으로 다시 sort by해서 불러오는 과정에서 디스크를 사용한다.
  - 이 때 레디스에서 sorted-set을 이용하면 더 쉬워진다.


## 하둡
컴퓨터 클러스터들이 대규모 데이터를 분산 처리할 수 있게 해주는 프레임워크

구성 : 대용량 파일을 분산해서 저장하는 분산파일 시스템 + 저장된 파일을 분산된 서버의 CPU와 메모리를 이용해서 분석하는 맵리듀스 플랫폼
