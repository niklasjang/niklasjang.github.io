---
title: "[기술면접] 운영체제"
excerpt: ""
date: 2020-10-25
categories:
  - JobInterview
tags:
  - JobInterview
toc : true
toc_label: "Table of contents"
toc_icon: "list"  # corresponding Font Awesome icon name (without fa prefix)
toc_sticky: true
classes: wide
---

8장 9장은 메모리, 가상메모리의 내용은 컴퓨터 아키텍쳐를 공부하고 다룹니다. 

# 파일 접근

파일에 접근하는 방법은 순차접근과 직접 접근이 있습니다. 맨 앞 또는 뒤에서 순차적으로 접근할 수 있고 offset을 지정해서 그만큼 이동한 뒤 순차접근을 할 수도 있습니다. 직접접근을 하기 위해서는 파일이 고정 길이의 논리 레코드의 집합으로 정의되는 경우 가능합니다. 

# 디렉터리 구조

디렉터리 구조를 어떻게 할당하고 관리하는가에 따라 시스템의 효율과 성능이 달라집니다. 

디렉터리도 데이터를 저장하는 방법이기 때문에 선형리스트(링크드 리스트) 또는 해시 테이블을 사용합니다.
해시 테이블의 경우 데이터는 선형리스트에 저장하고 주소를 빠르게 찾기 위해 해시함수를  사용하기도 합니다. 

자세한 내용은 자료구조에서 다룹니다. 

# inode

- 파일을 기술하는 디스크 상의 데이터 구조
- 파일의 데이터 블록이 디스크 상의 어느 주소에 위치하고 있는가 등의 파일에 대한 중요한 정보를 갖고 있다.

root directory의 ilist에서 /usr는 6번째inode에 정보가 저장되어 있음을 확인
6번째 inode를 확인하면 /usr directory의 정보가 132번째 블록에 들어있다는 것을 알 수 있음
132번째 블록에는 또 다른 ilist가 들어있음


inode는 데이터를 가리키는 포인터를 가지고 있습니다. 데이터에 대한 각 블록의 체크섬이 inode에 있습니다. 데이터에 문제가 있다면 그 체크섬이 바르지 않을 것이고 파일시스템은 이를 알 수 있습니다. 

# raid

# RAID 문제점

RAID는 운영체제나 사용자를 위해 데이터의 사용을 항상 보장하지 않습니다. 예를 들어 파일에 대한 포인터나 파일 구조 내에 있는 포인터들이 잘못될 수 있습니다. RAID는 물리적 매체의 오류는 보호하지만, 다른 하드웨어나 소프트웨어 에러는 보호하지 못합니다. 


# IO 시스템

하드웨어 장치는 port를 통해서 연결됩니다. 만약 하나 이상의 장치들이 공동으로 여려 선들을 사용한다며 이를  BUS라고 부릅니다.

# 인터럽트

CPU는 인터럽트 요청 라인이라고 불리는 선을 하나 가지고 있습니다. CPU는 매 명령어를 끝내고 다음 명령어를 수행하기 전에 늘 이선을 검사합니다. 입출력 하드웨어 제어기가 이 요청 라인에 신호를 보내면 CPU가 알아차리고 각종 레지스터 값과 상태정보를 저장한 다음, 메모리상의 인터럽트 핸들러 루틴으로 jump합니다.  인터럽트 핸들러는 인터럽트의 발생 원인을 조사하고 필요한 작업을 한뒤 CPU를 인터럽트 전의 실행상태로 되돌립니다. 

# 소프트웨어 인터럽트, 또는 trap

응용 프로그램은 시스템 호출을 수행하기 위해 소프트웨어 인터럽트 또는 trap이라는 명령어를 수행합니다. 이 명령어는 피연산자를 갖습니다. 시스템 호출이 트랩 명령어를 수행하면 인터럽트 하드웨어가 사용자의 코드 상태를 저장하고 커널모드로 전환 후 커널 루틴을 수행합니다. 
트랩은 입출력 장치 인터럽트에 비해 낮은 인터럽트 우선순위를 가집니다. 왜냐하면 시스템 호출은 네트워크나 디스크 서비스보다 긴급하지 않기 때문입니다. 

# 직접 메모리 접근, DMA. Direct memory Access

입출력 장치에 대해서 CPU가 1바이트씩 전송하는 것은 자원적인 낭비입니다. 많은 시스템들은 CPU가 1바이트씩 옮겨야하는 작업을 DMA에게 위임합니다.
DMA 전송을 시작하기 전에 호스트는 메모리에 DMA control block을 적재합니다. DMA control block에는 전송할 데이터가 있는 곳의 포인터와 전송할 장소의 포인터, 그리고 전송될 바이트 수를 기록합니다. 이렇게 DMA는 CPU 타입을 소비하지 않고 직접 버스를 통해 입출력을 수행합니다. 

# 블럭 입출력, 논블럭 입출력

응용 프로그램이 블럭 시스템 콜을 하면, 프로그램은 블락됩니다. 즉, 운영체제가 이 프로세스의 상태가 실행에서 대기로 변합니다. 입출력이 끝나면 프로세스는 다시 실행 상태가 됩니다. 실행이 재개되면 프로세스는 입출력 시스템 호출이 돌려준 값을 받게됩니다. 

논블록 시스템 콜은  오랜 기간 응용 프로그램을 멍춰두지 않고, 곧장 돌아오며 몇개의 바이트가 전송되었는지 알려주는 복귀값을 되돌려줍니다. 

다중 스레드의 경우 어떤 스레드는 블락형으로 동작하는 동시에 논블락형으로 동작할 수 있습니다.

논블락 시스템콜의 대안으로 비동기 시스템콜이 있습니다. 비동기 시스템콜도 위 호출처럼 즉각적으로 복귀합니다. 이 호출에서 돌아온 응용프로그램은 자신의 코드를 계속 수행합니다. 입출력이 완료되면 그때 가서 시그널이나 trap을 걸어서 콜백 루틴을 수행합니다. 

# 논블럭 입출력과 비동기 입출력의 차이

논블럭 입력의 경우 그시점에서 가지고 올 수 있는 데이터를 (전체 또는 일부)를 즉각적으로 가지고 복귀합니다.
반면 비동기식 읽기의 경우 입력이 완전히 끝난 후(시간이 좀 더 걸리더라도) 완전한 데이터를 전송합니다. 

# 폴링

호스트와 입출력 하드웨어 사이의 프로토콜은 복잡하지만, 기본적인 핸드셰이킹 개념은 간단합니다.
예를 들어 제어기와 호스트 사이에 생산자 소비자 관계를 조정하기 위해 두 개의 비트가 사용된다고 가정하겠습니다.
제어기는 상태 레지스터의 busy register를 통해 일하고 있는지 여부를 나타냅니다. 
호스트는 명령 레지스터의 명령 준비 완료 비트를 통해 자신이 입출력을 원한다는 신호를 나타냅니다.
호스트는 제어기의 busy register를 busy-waiting 즉, polling하고 있습니다. 호스트는 루프를 돌면서 계속해서 비지 비트가 소거될 때까지 검사를 반복합니다. 이 과정이 길면 매우 비효율적이기 때문에 하드웨어 제어기가 자신의 상태가 변함을 알려주는 인터럽트를 사용합니다. 


# 현대 = 비동기

디스크와 네트워크에서 비동기 입출력이 많이 쓰입니다. default로 네트워크 송신 요청과 디스크 쓰기 요청이 들어오면 운영체제는 요청을 버퍼에 넣고 응용으로 도돌아갑니다. 전체적 시스템 성능을 최적화하기 위해서 운영체제는 여력이 생길 때 요청을 완료합니다. 중간에 시스템이 고장나면 요청을 잃어버리기 때문에 버퍼링에 제한시간을 설정합니다. 

논블럭형의 좋은 예시가 네트워크 소켓 select 시스템입니다. 이 시스템 호출은 최대 대기 시간을 인자로 지정합니다. 0으로 지정하면 응용프로그램은 블락없이 네트워크에 대한 polling만을 수행합니다. 그러나 select르 사용하는 ㅓㅅ은 추가적ㅇ니 오버헤드가 될 수 있습니다. select 호출은 단지 입출력이 가능한지만 검사합니다. 실제 데이터를 전송하려면 read와 write이 뒤따라야 합니다.

select와 다르게 Mash는 blocking multi read 호출을 제공합니다. 이 시스템호출은 한 번부르면 몇 개의 입출력 장치를 검사하고 그 중하나라도 데이터를 가지고 있으면 데이터와 함께 즉시 복귀합니다.  


# select, poll, epoll

- select
  - 단일 스레드에서 여러 파일의 입출력 처리가 가능합니다.
  - fd_set을 사용해 하나 이상의 fd가 준비되거나 timeout이 완료될 때까지 대기합니다.
  - 표준 입력,출력,에러에 대한 3개의 fe_Set을 사용합니다.
  - 1024개의 fd 관리 제한
  - FD_SET을 계속해서 select문을 통해서 운영체제에게 전달하는 것도 큰 부하
poll
  + fd_Set으로 입력,출력,에러를 구분해서 관리하는 select와 달리 pollfd 구조체를 관리할 fd의 갯수만큼 사용합니다.
  + 매번 이벤트의 값을 신경써야하는 select와 달리 이벤트 발생정보를 매번 신경쓰지 않아도 됩니다.   
  + 타임아웃 값을 세팅할 때 별다른 구조체를 사용하지 않고 타임아웃을 설정할 수 있습니다.
  - 일부 unix 시스템에서는 poll을 지원하지 않습니다. 
epoll
  - select와 달리 전체 fd에 대한 반복문을 수행하지 않습니다.
  - 관찰 대상의 정보를 커널에게 전달하는 방식이 아니라, 관찰 대상fd들의 정보를 저장하느 저장소를 운영체제가 직접 관리합니다.

























