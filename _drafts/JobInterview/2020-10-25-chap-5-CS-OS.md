---
title: "[기술면접] 운영체제"
excerpt: ""
date: 2020-10-25
categories:
  - JobInterview
tags:
  - JobInterview
toc : true
toc_label: "Table of contents"
toc_icon: "list"  # corresponding Font Awesome icon name (without fa prefix)
toc_sticky: true
classes: wide
---

# 시스템 호출, 커널
응용 프로그램은 운영체제가 제공하는 서비스를 사용하기 위해서 커널에게 시스템콜을 보냅니다. 

# 프로세스
프로세스는 메모리에 적재되어 실행중인 프로그램을 의미합니다.
하나의 시스템은 프로세스의 집합이고, 프로세스는 시분할 시스템에서 작업의 단위입니다.

운영체제는 프로세스를 linked list로 구성된 프로세스 control block으로 관리합니다. 
프로세스 control block에는 프로세스 상태, 프로그램 카운터, cpu 레지스터 등으로 구성됩니다.
  - 프로세스는 생성, 준비완료, 대기, 종료의 상태를 가집니다. 
  - 프로그램 카운터는 다음에 실행할 명령어의 주소를 가리킵니다. 
  - 레지스터는 프로세스를 실행하는데 필요한 정보를 담고 있습니다. 
  - base register와 limit register의 정보를 가지고 있어 고유한 메모리 영역을 가집니다. 

# 프로세스 장,단,중기 스캐줄링

프로세스 스캐줄링은 프로세스가 실행되는 동안 사요자와 상호작용을 할 수 있도록 프로세스들 사이에서 CPU를 빈번하게 교체하는 것을 말합니다. 

프로세스가 실행되면 PCB는 CPU의 JOB Queue에 등록됩니다.
특정 입출력 장치를 대기하는 프로세스의 경우 Device의 Job Queue에 PCB이 등록됩니다.
Job Queue에 등록된 PCB은 CPU를 할당받을 때까지 준비완료 큐에서 대기합니다. 
프로세스가 모두 실행되고나면 PCB의 자원을 반납합니다. 

장기 스케줄러는 프로세스를 선택하여 메모리에 적재하는 역할을 합니다.
단기 스케줄러는 실행 준비가 완료된 프로세스들 중 하나를 선택해서 CPU에 할당합니다. 
unix와 window의 경우 장기 스케줄러 대신 중기 스케줄러가 존재합니다.
중기 스케줄러는 프로세스 스케줄링 방법에 따라  프로세스를 제거하여 다중 프로그래밍의 강도를 완화합니다.
예를 들어 IO작업을 수행하는 프로세스를 메모리에서 제거했다가, IO가 완료되면 다시 메모리에 적재합니다. 

## cpu burst, IO burst

프로세스 스케줄링은 CPU burst 사이클과 IO burst 사이클을 번갈아가며 수행합니다. 
프로그램의 특성에 따라 CPU burst와 IO burst의 빈도가 달라집니다. 

# 프로세스 상태 변환

1. 입출력 요청을 받거나, 자식 프로세스가 종료되기를  기다릴 때는 실행 -> 대기 상태로 전환됩니다.
1. 입출력이 종료되면 대기 상태에서 준비 완료 상태로 전환됩니다.
1. 인터럽트가 발생하면 실행 -> 준비 완료로 전환됩니다.
1. 프로세스가 종료하면 실행 -> 종료 상태로 전환됩니다.

# 선점형, 비선점형 스캐줄링

프로세스 스케줄링 방법은 크게 선점 스케줄링과 비선점 스케줄링으로 나뉩니다. 

개인적으로는 선점이라는 말보다 강탈이라는 말로 이해하고 있습니다.
선점형 스케줄링 방식은 CPU를 방출할 때까지 기다리지 않고 CPU 타임을 가져갑니다.

# 프로세스 스캐줄링 방법

1. First Come, First Serve : 선입 선출 : 비선점형
1. Shortest Job First : 전체 작업시간 기준 : 비선점형
1. Priority : 미리 정해진 우선순위 기준 : 비선점형

1. Round-Robin : 시간 할당량을 정하고 그만큼 순서대로 할당 : 선점형

# 스레드 스케줄링

프로세스 모델에 스레드가 도입되면서 사용자 수준 스레드와 커널 수준 스레드가 구별되었습니다. 
스레드가 도입된 이후, 운영체제가 관리하는 스케줄링의 대상은 커널 수준의 스레드입니다.
사용자 수준의 스레드는 스레드 라이브러리에 의해서 관리됩니다. 
따라서 스레드 수준으로 스케줄링을 하고 있다는 말은 스레드가 CPU에 의해서 실행되고 있다는 것을 반드시 의미하지는 않습니다.
실제로 CPU 상에서 실행되기 되는 것은 운영체제가 커널 스레드를 CPU로 스케줄링을 한 이후에 수행됩니다. 

# 임계구역

임계구역은 프로세스들이 협역할 때, 자신을 제외한 다른 프로세스는 들어올 수 없는 구역을 의미합니다. 

임계구역에 여러 프로세스들이 동시에 들어오면 임계구역에서 사용하는 메모리에 대해서 명령어의 순서가 뒤섞여 원하는 결과를 얻지 못할 수 있습니다.

이를 해결하기 위한 방법은 Mutex Lock와 Semaphor가 있습니다.
Mutex는 Mutual exclusion이라는 의미입니다. 프로세스는 임계구역에 들어가기 전에 반드시 mutex lock을 획득해야하고, 빠져나올 때는 lock을 반환해야 합니다.
락을 얻는 함수는 acquire() 리턴하는 함수는 release()입니다. acquire()를 호출하고 락을 얻지 못한다면 락을 얻을 때까지 block됩니다. 이렇게 락을 얻을 때까지 계속 프로세스가 회전하고 있기 때문에 spinlock()이라고 부릅니다. 

semaphor는 프로세스들의 행동을 더 정교하게 동기화할 수 있는 방법을 제공합니다. 
락을 얻는 연산은 P연산, 락을 해제하는 연산은 V연산입니다. 그리고 각각 wait()과 signal()이라고 불립니다.
세마포는 다시 카운팅세마포와 바이너리 세마포로 나뉩니다. 카운틴 세마포는 임계 영역에 유한한 갯수만큼 자원에 동시 접근을 허용합니다.

## 데드락. 교착상태

데드락이 발생하기 위해서는 세 가지 조건이 필요합니다. 1. mutex 2. 비선점 3. 점유하며 순환대기 입니다.

데드락 해제를 하기 위해서는 선점형 스케줄링을 사용하거나 점유 순환대기를 풀기 위해 프로세스의 재부팅을 사용합니다.


## 인터럽트, 커널모드

스케줄러에 의해서 interrupt가 발생하면 다음과 같은 순서로 수행합니다.
  1. 현재의 state를 저장합니다.
  1. kernel 모드에 진입합니다.
  1. interrupt handler가 어떤 kernel 코드를 수행할지 판단합니다.
  1. kernel 코드가 실행됩니다. 
이 때, 커널프로세스를 실행하는 주체는 Main CPU일 수도 있고, Device CPU일 수도 있습니다. 

# 컨텍스트 스위칭

CPU가 진행중인 프로세스를 중단하고 새로운 프로세스를 실행하는 것을 컨텍스트 스위칭이라고 합니다.
이 때 CPU는 진행중이던 프로세스의 정보를 PCB에 저장하고 새로운 프로세스를 실행합니다.
이러한 컨텍스트 스위칭의 시간동안에는 유용한 일을 수행하지 못하기 때문에 순수한 오버헤드 시간으로 간주됩니다.

# 프로세스 간의 통신

프로세스 간의 통신은 공유 메모리를 사용하는 방법과 메시지를 교환하는 방법이 있습니다. 


# 프로세스와 스레드의 관계

현대의 프로세스는 다수의 스레드를 실행할 수 있도록 구성되어 있습니다.
따라서 프로세스가 한 번에 여러 개의 일을 수행할 수 있습니다.
스레드의 정보는 앞서 말씀드린 프로세스 control block에 저장되어서 관리됩니다. 

스레드는 CPU 이용의 기본 단위입니다. 스레드는 스레드ID, 프로그램카운터, 레지스터 그리고 스택으로 구성됩니다. 
스레드는 같은 프로세스에 속한 다른 스레드와 code segment, data segment, heap segment 그리고 파일과 같은 운영체제 자원들을 공유합니다. 

# 스레드풀

프로세스 내에서 스레드를 무한히 생성하면 CPU 시간과, 메모리 공간와 같은 시스템 자원이 고갈됩니다.
따라서 프로세스가 실행될 때 일정한 수의 스레드를 미리 생성하고, 작업 요청이 들어왔을 때 이를 사용하는 방법인 스레드풀을 사용합니다. 
스레드풀은 한 개의 요청이 들어오면 한 스레드를 할당합니다. 요청을 다 수행한 스레드는 다시 풀로 돌아가서 다음 작업을 기다립니다.



----


정의 : 메모리에 적재되어 실행 중인 프로그램의 인스턴스
특징 : 
  - 독립적인 메모리 공간을 가진다.
    - Code
    - Data 
    - Stack :  Stack은 메모리 주소가 높은 영역부터 채워짐.
    - Heap : Heap은 메모리 주소가 낮은 영역부터 채워짐
  - 프로세스는 최소 한개의 쓰레드를 가진다.
## semaphor
정의 : 공유되는 자원을 하나의 `프로세스`에만 접근하도록 사용 권한을 제한하는 매커니즘.
연산 : P연산 = wait, V 연산 = signal
목적 : dead lock을 피하기 위함

## deadlock
프로세스가 자원을 얻지 못해 다음 처리를 하지 못하는 상태 

# thread
정의 : 프로세스 내에서 실행되는 여러 흐름의 단위
특징 :
  - 생성시 stack과 register만 새로 할당한다. 
  - Code, data, heap 영역은 공유한다.

## mutex
정의 :공유되는 자원을 하나의 `쓰레드`에만 접근하도록 사용 권한을 제한하는 매커니즘. mutex = binary semaphor
연산 : lock과 unlock이 있다
목적 : critical section을 가진 Thread의 상호 배제

## race condition
다수의 쓰레드가 같은 자원에 접근할 때 동기화 과정이 적용되지 않는 것

## critical section 
공유되는 자원이 독점됨을 보장하는 영역

## condition variable
lock 되어 있는 mutex 객체를 특정 조건에서 unlock 시키는 매커니즘

## context switch
정의 : 상태를 보관하고 이전 프로세스 상태를 복구시키는 작업
프로세스 :
  - 프로세스 간 공유하는 메모리가 없기 때문에, CPU 레지스터 교체뿐만 아니라 캐시 메모리 초기화까지 진행되어 오버헤드가 크다

# 멀티프로세스

정의 : 하나의 응용을 여러 프로세스로 나누어 각 프로세스가 하나의 작업을 수행
장점 : 하나의 프로세스에서의 에러는 다른 프로세스에 영향을 주지 않음
단점 : context switching 오버헤드

## 프로세스 스케줄링

정의 : CPU가 메모리에 적재된 여러 개의 프로세스를 번갈아서 실행하면서, CPU 할당 수서 및 방법을 결정 짓는 것
상태 : 
  - Ready : 우선순위가 더 높은 프로세스가 실행되면 ready 상태로
  - Running
  - Blocked : 스케줄러에 의해 선택이 되지 않은 프로세스

# 멀티쓰레드
정의 : 하나의 응용을 여러 쓰레드로 나누어 각 쓰레드가 하나의 작업을 수행
장점 :
  - 시스템 자원 소모 감소(프로세스 생성 및 자원 할당을 위한 시스템 콜이 줄어든다)
  - 쓰레드 간 데이터를 주고 받는 것이 상대적으로 간단하다.
  - context switching 비용이 프로세스보다 적다.
단점 :
  - 단일 프로시스 시스템에서는 효과를 기대할 수 없다.
  - race condition 문제가 발생한다.
  - 하나의 쓰레드에 문제가 발생하면 전체 프로세스가 영향을 받는다. 

# 선점형 OS, 비선점형 OS

의미상 선점형보다 강탈형, 비강탈형이라고 기억하는 것이 더 쉽다.  

선점형 : 하나의 프로세스가 다른 프로세스 대신에 CPU를 차지할 수 있다.
  - Round Robin : 시간 단위가 설정되어 각 시간 동안 프로세스를 실행하고 다음 프로세스로 전환 
비선점형 : 하나의 프로세스가 끝나지 않으면 다른 프로세스는 CPU를 사용할 수 없다.
  - FIFO
  - SJF
  - HRN : 우선순위와 대기 시간에 따라 작업 할당

## 병렬 처리

여러 작업을 동시에 처리할 수 있게 하는 병렬 처리 시스템. 
컴퓨터를 병렬 연결 또는 CPU를 병렬 연결

## 분산 처리
분산된 데이터 저장장소 및 처리기들을 네트워크로 연결하여 서로 통신을 하면서 작업을 수행하는 것. 여러 컴퓨터가 작업을 나누어서 처리한다. 
master가 worker에 작업을 할당하는 것이라고 생각하면 된다. 

# 크롬 탭이 프로세스인지 쓰레드인가요

크롬은 탭마다 PID를 가지고 있으니 Process이며 각 Tab마다 랜더링 정보나 기타 데이터를 따로 관리한다고 한다. 그로인해 메모리를 많이 잡아먹기도 하지만 하나의 Tab에 오류가 생겼다고 모든 Tab에 영향을 끼치진 않는다.