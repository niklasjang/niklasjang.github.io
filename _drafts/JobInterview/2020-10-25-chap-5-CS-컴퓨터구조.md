---
title: "[기술면접] 컴퓨터구조"
excerpt: ""
date: 2020-10-25
categories:
  - JobInterview
tags:
  - JobInterview
toc : true
toc_label: "Table of contents"
toc_icon: "list"  # corresponding Font Awesome icon name (without fa prefix)
toc_sticky: true
classes: wide
---

## 컴퓨터가 켜지는 과정

1. 컴퓨터에 전원이 들어옵니다. 
1. ROM에 저장된 부트로더가 실행됩니다. 
1. 부트로더가 운영체제 커널을 찾아서 메모리에 적재합니다.
1. 부트로더가 제어권을 운영체제에게 저달합니다.

## 컴파일러, 인터프리터

컴파일러는 고급언어로 작성된 프로그램을 저급언어로 구성된 목적 프로그램으로 변환해줍니다.
변환이 끝난 목적 프로그램은 실행을 위해 컴퓨터의 메모리에 적재되어야 합니다.

인터프리터는 고급언어에서 하나의 명령어를 분석해서 동일한 효과를 가진 저급언어 명령어로 변환하고 실행합니다.
전체 프로그램이 종료될 때까지 이 과정을 반복합니다. 

## 무어의 법칙

단일 칩에 포함된 트랜지스터의 갯수가 18개월마다 2배씩 증가한다.

## 암달의 법칙

시스템의 일부를 개선할 때 전체 시스템에서 얻을 수 있는 최대 성능을 구하는데 사용됩니다.

프로그램에서 병렬화를 진행할 수 없는 부분이 있기 때문에 시스템 성능을 무한대로 늘리는데에는 한계가 있습니다.

## CPU 성능 분석

프로그램 내 명령어 갯수 * 명령어 내 사이클 갯수 * 사이클당 걸리는 시간 = 프로그램당 걸리는 시간

사이클당 시간의 역수 = 클록 속도.
inline함수를 사용하면 코드의 크기가 증가하지만 함수 호출 비용을 줄일 수 있으므로 성능 향상에 도움이 될 수 있다. 

## 밴치마크

시스템의 성능을 측정하기 위해서, 일반적으로 자주 이용되는 프로그램을 사용합니다.
일 때 작업 부하로 선택된 프로그램을 밴치마크라고 합니다. 

## CPU 구조

PC, program counter : 다음이 실행할 명령어의 주소를 보관하는 레지스터
ACC, accumulator, 누산기 : 데이터를 일시적으로 보관하는 레지스터
IR : instruction register : 가장 최근에 인출한 명령어 저장하는 레지스터

MAR : memory address register : 
MBR : memory buffer register : 

디스크 -> 메모리 : 적재
프로세서는 데이터가 저장되어 있는 메모리의 주소를 MAR에 저장한다.
MAR이 지정하는 메모리 주소에서 데이터를 가져와서 MBR에 저장한다. 그리고 프로세서가 MBR에 저장된 데이터를 읽는다.

메모리 -> 디스크 : 저장
프로세스는 데이터를 저장할 주소를 MAR에 보낸다.
프로세서는 저장할 데이터를 MBR에 보낸다.
메로리는 MAR이 가리키는 위치에 MBR의 데이터를 저장한다. 

## 32bit, 64bit, 워드

먼저 메모리의 주소는 Byte 단위로 주어집니다.
워드는 메모리 주소 공간의 크기입니다. 워드의 크기가 32/64bit인지에 따라서 32/64bit 시스템으로 결정됩니다.
따라서 32bit 컴퓨터에서는 메모리가 최대 2^32byte = 4GB입니다. 

## 주소 지정방식, 빅엔디언, 리틀엔디언

CPU에 따라서 4바이트 정수 1을 메모리공간에 저장하는 방식이 달라집니다. 
4바이트 정수 1을 2진수로 표현하면 00000000 00000000 00000000 00000001입니다. 
4바이트 정수 1을 16진수로 표현하면 0x00 0x00 0x00 0x01입니다. 
이 순서를 메모리에 저장하는 방식에 따라서 `빅엔디안`과 `리틀엔디안`이 나눠진다.

- 빅 엔디안 : 상위 바이트 값을 작은 번지수에 저장하는 방식
    - 메모리 주소   : 0x20  0x21  0x22  0x23
    - 저장할 데이터 : 0x12345678(0x12가 최상위 바이트)
    - 저장된 데이터 : 0x12  0x34  0x56  0x78
- 리틀 엔디안 : 상위 바이트의 값을 큰 번지수에 저장하는 방식
    - 메모리 주소   : 0x20  0x21  0x22  0x23
    - 저장할 데이터 : 0x12345678
    - 저장된 데이터 : 0x78  0x56  0x34  0x12

네트워트를 통해서 바이트를 전송할 때는 `빅 엔디안`의 기준을 따릅니다. 

그래서 `htons()`, `ntohs()`, `htonl()`, `ntohl()`의 함수를 사용해서 네트워크 바이트 오더로 변환을 한다. 

일반적으로 인텔이나 AMD CPU는 리틀엔디안을 사용하기 때문에 htons()를 사용하는 것이 필수적이다.  

하지만 데이터를 전송하기 전에 다 바꿔줘야 하는 것은 아니다. 
데이터를 보내면 자동으로 네트워크 바이트 오더로 바꿔주고, 수신하면 호스트 바이트 오더로 바꿔준다. 
이는 sockaddr_in의 구조체에 변수 데이터를 채울 때는 제외하고는 신경을 쓰지 않아도 된다. 

## 주소 지정 방식

0단계 주소 지정 방식 : 명령어의 피연산자에 데이터가 바로 지정되거나, ACC누산기에 있는 데이터를 사용하는 경우입니다.
1단계 주소 지정 방식 : 데이터의 주소를 알기 위해서 주소 계산이나 읽기 연산을 1번 수행해야하는 방식입니다.

## 1의 보수, 2의보수

부호가 있는 정수를 표현하는 방식에는 2의 보수 방법과 1의 보수 방법이 있습니다.

1의 보수 : 음수를 표현하기 위해서 각 비트를 0과 1사이에 상호 반전합니다. 
가장 앞에 있는 비트를 MSB로 사용합니다. 1101은 음수이고(1), 101을 반전하면 (010)이기 때문에 -2를 나타냅니다.
문제점은 0111은 +0이고 1111은 -0이라는 점입니다.

2의 보수 : 양의 정수와 +0에 대해서는 1의 보수 방법을 사용합니다. -0은 존재하지 않고, 음의 정수는 1의 보수 방법에서 1을 더해서 표현합니다.
특정 값의 2의
0000의 보수 : -0가 존재하지 않기 때문에 구할 수 없다.
0001의 보수 : 0001 -> 1110 -> 1111 
보수 구하지 않고 바로 값 구하기 0111 = 0 * 2^3 + 2^2 + 2^1 + 2^0 = 0 + 4 + 2 + 1 = 7
보수 구하지 않고 바로 값 구하기 1111 = -1 * 2^3 + 2^2 + 2^1 + 2^0 = -8 + 4 + 2 + 1 = -1
보수 구해서 값 구하기 1111 -> 음수 + 111 -> 음수 + 110 -> 음수 + 001 -> -1

## 논리게이드

& | ~ ^
^ : 다르면 1, 같으면 0

## n번째 비트 바꾸기

- n번째 비트를 1로 바꾸기 **number |= 1 << x**
A = 0000
첫 번째 비트를 1로 만들기  : B = 0001, A |= B;
두 번째 비트를 1로 만들기  : B = 0010, A |= B;
N 번째 비트를 1로 만들기 : B = 1 \<\< n, A |= B;

- n번째 비트를 0으로 바꾸기 **number &= ~(1<< x)**
A = 1111
첫 번째 비트를 1로 만들기 : B = 1110, A &=B (A의 비트가 1이면 1로, 0이면 0으로, target은 항상 0으로)
두 번째 비트를 1로 만들기 : B = 1101, A &=B 
N 번째 비트를 0으로 만들기 : B = ~(1 << n), A &=B

- n번째 비트를 0이면 1로, 1이면 0으로 바꾸기 **number ^= 1 << x**
^는 다르면 1, 같으면 0
0000 ^= 1 << 1
0000 ^= 0001 --> 1110 
## 병렬처리와 파이프라이닝

CPU의  성능을 계산하기 위해서는 프로그램당 명령어 수, 명령어당 사이클 수, 사이클 당 소요 시간을 곱해야합니다.
이때 명령어당 사이클수는 CPI라고도 하며 명령어마다 필요한 클럭 사이클의 수가 다르기 때문에 평균 CPI를 사용합니다.
CPI를 최적화 하기 위한 방법으로는 병렬처리와 파이프라이닝이 있습니다. 

병렬처리는 여러 개의 잡을 각각의 시스템에서 동시에 처리하는 것을 말합니다.
파이프라이닝은 하나의 시스템 안에서 특정 잡을 작은 단위로 나누어서 처리하는 것을 말합니다.
특정 잡이 ABCD 4가지 성질로 나누어질 때 시스템은 ABCD의 업무를 동시에 수행할 수 있다는 점을 이용합니다.
바꿔말하면 명령어 실행이 중첩되기 때문에 프로세서의 성능이 향상됩니다. 
파이프라이닝의 전체 소요 시간은 ABCD 중에서 가장 오랜 시간이 걸리는 잡에 의해서 결정됩니다. 

## 해저드

이상적인 경우에서 m 단계 파이프라이닝을 적용하면 m 배의 성능 향상을 기대할 수 있습니다. 
그런다 구조적 해저드, 데이터 해저드, 명령어 해저드에 따라서 실제로는 m배보다 낮은 수준의 성능향상만이 적용됩니다.

구조적 해저드는 동시에 실행중인 명령어가 동일한 하드웨어 자원을 동시에 요구하는 것을 말합니다.
데이터 해저드는 연산할 데이터가 준비되지 않아서 다른 명령어의 결과를 기다리는 것을 말합니다. 선행 명령어와 후행 명령어의 R/W 관계에 따라 R-W W-R W-W 세 가지 경우로 나뉩니다.
명령어 해저드는 실행할 명령어가 준비되어 있지 않아서 파이프라인을 멈추어야 하는 상황을 말합니다. 

## 해저드 해결방법

비용을 추가할 수 있다면 하드웨어를 추가하거나 파이프라인을 다시 설계할 수 있습니다.
적은 비용으로 해저드를 해결하기 위해서는 가장 많이 발생하는 데이터 해저드를 개선하는 것이 좋습니다.
선행 명령어의 결과를 기다리는 후행명령어가 선행 명령어의 결과를 바로 가져갈 수 있도록 별도의 파이프를 추가하는 방법이 있습니다.
예를 들어 선행 명령어의 결과가 적재되었다가 후행명려어에 전달되는데, 적재할 하드웨어 자원이 구조적 해저드에 의해서 멈추어있을 때 후행명령어가 미리 값을 가져올 수 있는 경로를 추가하는 것입니다. 

## 메모리

메모리는 실행될 프로그램과 데이터가 머무는 장소를 의미합니다. 
CPU와 메모리 사이의 데이터 전송은 MAR, MBR을 사용합니다. 

## 메모리 지역성의 원리

시간적 지역성 : 최근에 참조된 명령어나 데이터를 더 참조하는 경향을 말합니다.
공간적 지역성 : 최근에 참조된 명령어나 데이터의 이웃이 가까운 미래에 참조되는 경향을 말합니다. 

## 메모리 계층

레지스터는 컴파일러가 관리합니다.
캐시 메모리는 하드웨어가 관리합니다
메모리는 운영체제가 관리합니다.
보조기억장치는 운영체제 또는 별도의 디바이스가 관리합니다. 

# 캐시 메모리

캐시 메모리의 적중률은 (캐시 메모리의 적중 회수) / (전체 메모리의 참조 횟수)로 계산합니다.
캐시 메모리의 적중은 CPU가 필요한 데이터가 캐시메모리가 가지고 있는 워드에 포함되어 있는 것을 말합니다. 
만약 캐시 메모리에 필요한 워드가 없다면 
메모리에게 요청을 하고, 
메모리에도 없다면 보조기억장치에 페이지를 요청합니다. 
지역성의 원리가 얼마나 적용되는지에 따라 적중률이 달라집니다. 

캐시 메모리는 태그메모리와 데이터메모리고 나뉩니다.

태그메모리는 태그, 갱신 비트, 유효 비트를 가지고 있습니다.
태그는 CPU가 요청한 데이터가 데이터 메모리에 있는지 확인하는데 사용되는 주소 정보의 일부입니다.
갱신 비트는 대응되는 블록을 캐시메모리로 가져온 이후 갱신이 되었는지를 표시합니다.
유효 비트는 캐시 블록이 유효한지를 나타냅니다. 컴퓨터가 부팅될 때 모든 유효비트가 무효로 초기화됩니다. 

## 캐시 메모리 사상방식

캐시 메모리 사상방식은 메인 메모리에서 어떤 블록을 캐시 메모리 속의 데이터메모리로 적재할지 결정하는 방법입니다. 

예시 시스템
  - 빅엔디안
  - 512바이트 메모리
  - 128바이트 캐시
  - 16바이트 블록크기
    - 메모리는 512/16 = 32개의 블록
    - 캐시는 128/16 = 8개의 블록을 가짐
  - 4바이트 워드 크기

메모리의 주소는 512 = 2^9이므로 9바이트
메모리 블록의 주소 = 블록갯수32개 = 2^5이므로 5바이트
캐시의 주소는 128 = 2^7이므로 7바이트
캐시 블록이 8 = 2^3이므로 3바이트

메모리와 캐시의 블록은 동일하게 16 = 2^4 이므로 블록 오프셋은 4비트
메모리 주소 9바이트 00000 0000(오프셋 4비트)
캐시 주소 7바이트     000 0000(오프샛 4비트)

직접 사상방식 : 모듈러 연산을 사용해서 메모리 블록을 정해진 캐시 블록에만 사상하는 방식
메모리 블럭 번호 mod 캐시 블럭 수 = 캐시 블럭 번호
32개 mod 8개 = 메모리 블럭이 사상될 캐시 블럭 번호
mod 8 = 마지막 비트 3자리를 구한다는 의미 = 메모리 블럭 주소 5비트 중 하위 3비트를 추출한다는 뜻.
캐시 메모리의 태그 메모리는 5비트에서 상위 2비트를 태그에 저장한다. 

완전 연관 사상방식 : 메모리 블럭의 주소와 상관없이 모든 캐시 블럭에 사상될 수 있다.
따라서 캐시 메모리의 태그 메모리는 메모리 블럭의 주소 5비트를 모두 저장한다. 

집합 연관 사상 : 두 사상 방식을 섞은 방식
메모리 블럭이 사상될 수 있는 구역이 2개 이상의 캐시 블록이다. 2개일 때 2방향 집합 연관 사상이라고 부른다.
두 개의 블록 중 어떤 캐시블록에도 사상할 수 있는 방식입니다. 
메모리 블록의 수 mod (캐시 블록의 수 / 캐시 집합의 크기) = 캐시 블록 번호

## 가상기억 장치

프로세스가 사용하는 주소 공간과 프로그램이 저장된 주소 공간을 분리해서 메모리를 효율적으로 사용할 수 있도록 합니다.
= 가장기억장치는 보조기억장치의 일부를 메모리처럼 사용함으로써 용량이 작은 메모리를 큰 용량처럼 보이게 합니다. 

페이징 : 프로그램을 논리적인 의미와 상관없이 일정한 크기의 페이지로 분할
세그멘테이션 : 프로그램을 논리적인 의미와 상관있는 일정한 크기의 세그먼트로 분할
페이지 내부 파편화
세그멘테이션 외부 파편화


## 바이너리 세마포, 뮤텍스 차이점


